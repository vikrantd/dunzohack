{"remainingRequest":"/Users/Ayush.Nair/Documents/naira/dunzohack/ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/Ayush.Nair/Documents/naira/dunzohack/ui/node_modules/@ngrx/store-devtools/@ngrx/store-devtools.es5.js","dependencies":[{"path":"/Users/Ayush.Nair/Documents/naira/dunzohack/ui/node_modules/@ngrx/store-devtools/@ngrx/store-devtools.es5.js","mtime":1510095324000},{"path":"/Users/Ayush.Nair/Documents/naira/dunzohack/ui/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/Ayush.Nair/Documents/naira/dunzohack/ui/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Inject, Injectable, InjectionToken, NgModule } from '@angular/core';\nimport { ActionsSubject, INIT, INITIAL_STATE, ReducerManagerDispatcher, ReducerObservable, ScannedActionsSubject, StateObservable, UPDATE } from '@ngrx/store';\nimport { ReplaySubject as ReplaySubject$1 } from 'rxjs/ReplaySubject';\nimport { map as map$1 } from 'rxjs/operator/map';\nimport { merge as merge$1 } from 'rxjs/operator/merge';\nimport { observeOn as observeOn$1 } from 'rxjs/operator/observeOn';\nimport { scan as scan$1 } from 'rxjs/operator/scan';\nimport { skip as skip$1 } from 'rxjs/operator/skip';\nimport { withLatestFrom as withLatestFrom$1 } from 'rxjs/operator/withLatestFrom';\nimport { queue as queue$1 } from 'rxjs/scheduler/queue';\nimport { Observable as Observable$1 } from 'rxjs/Observable';\nimport { empty as empty$1 } from 'rxjs/observable/empty';\nimport { filter as filter$1 } from 'rxjs/operator/filter';\nimport { share as share$1 } from 'rxjs/operator/share';\nimport { switchMap as switchMap$1 } from 'rxjs/operator/switchMap';\nimport { takeUntil as takeUntil$1 } from 'rxjs/operator/takeUntil';\nvar PERFORM_ACTION = 'PERFORM_ACTION';\nvar RESET = 'RESET';\nvar ROLLBACK = 'ROLLBACK';\nvar COMMIT = 'COMMIT';\nvar SWEEP = 'SWEEP';\nvar TOGGLE_ACTION = 'TOGGLE_ACTION';\nvar SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nvar JUMP_TO_STATE = 'JUMP_TO_STATE';\nvar IMPORT_STATE = 'IMPORT_STATE';\nvar PerformAction = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} action\n     * @param {?=} timestamp\n     */\n    function PerformAction(action, timestamp) {\n        this.action = action;\n        this.timestamp = timestamp;\n        this.type = PERFORM_ACTION;\n        if (typeof action.type === 'undefined') {\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\n                'Have you misspelled a constant?');\n        }\n    }\n    return PerformAction;\n}());\nvar Reset = /*@__PURE__*/ (function () {\n    /**\n     * @param {?=} timestamp\n     */\n    function Reset(timestamp) {\n        this.timestamp = timestamp;\n        this.type = RESET;\n    }\n    return Reset;\n}());\nvar Rollback = /*@__PURE__*/ (function () {\n    /**\n     * @param {?=} timestamp\n     */\n    function Rollback(timestamp) {\n        this.timestamp = timestamp;\n        this.type = ROLLBACK;\n    }\n    return Rollback;\n}());\nvar Commit = /*@__PURE__*/ (function () {\n    /**\n     * @param {?=} timestamp\n     */\n    function Commit(timestamp) {\n        this.timestamp = timestamp;\n        this.type = COMMIT;\n    }\n    return Commit;\n}());\nvar Sweep = /*@__PURE__*/ (function () {\n    function Sweep() {\n        this.type = SWEEP;\n    }\n    return Sweep;\n}());\nvar ToggleAction = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} id\n     */\n    function ToggleAction(id) {\n        this.id = id;\n        this.type = TOGGLE_ACTION;\n    }\n    return ToggleAction;\n}());\nvar JumpToState = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} index\n     */\n    function JumpToState(index) {\n        this.index = index;\n        this.type = JUMP_TO_STATE;\n    }\n    return JumpToState;\n}());\nvar ImportState = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} nextLiftedState\n     */\n    function ImportState(nextLiftedState) {\n        this.nextLiftedState = nextLiftedState;\n        this.type = IMPORT_STATE;\n    }\n    return ImportState;\n}());\n/**\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\nfunction difference(first, second) {\n    return first.filter(function (item) { return second.indexOf(item) < 0; });\n}\n/**\n * Provides an app's view into the state of the lifted store.\n * @param {?} liftedState\n * @return {?}\n */\nfunction unliftState(liftedState) {\n    var computedStates = liftedState.computedStates, currentStateIndex = liftedState.currentStateIndex;\n    var state = computedStates[currentStateIndex].state;\n    return state;\n}\n/**\n * @param {?} liftedState\n * @return {?}\n */\n/**\n * Lifts an app's action into an action on the lifted store.\n * @param {?} action\n * @return {?}\n */\nfunction liftAction(action) {\n    return new PerformAction(action);\n}\n/**\n * @param {?} input$\n * @param {?} operators\n * @return {?}\n */\nfunction applyOperators(input$, operators) {\n    return operators.reduce(function (source$, _a) {\n        var operator = _a[0], args = _a.slice(1);\n        return operator.apply(source$, args);\n    }, input$);\n}\nvar ExtensionActionTypes = {\n    START: 'START',\n    DISPATCH: 'DISPATCH',\n    STOP: 'STOP',\n    ACTION: 'ACTION',\n};\nvar REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');\nvar DevtoolsExtension = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} devtoolsExtension\n     */\n    function DevtoolsExtension(devtoolsExtension) {\n        this.instanceId = \"ngrx-store-\" + Date.now();\n        this.devtoolsExtension = devtoolsExtension;\n        this.createActionStreams();\n    }\n    /**\n     * @param {?} action\n     * @param {?} state\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.notify = function (action, state) {\n        if (!this.devtoolsExtension) {\n            return;\n        }\n        this.devtoolsExtension.send(null, state, { serialize: false }, this.instanceId);\n    };\n    /**\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.createChangesObservable = function () {\n        var _this = this;\n        if (!this.devtoolsExtension) {\n            return empty$1();\n        }\n        return new Observable$1(function (subscriber) {\n            var /** @type {?} */ connection = _this.devtoolsExtension.connect({\n                instanceId: _this.instanceId,\n            });\n            connection.subscribe(function (change) { return subscriber.next(change); });\n            return connection.unsubscribe;\n        });\n    };\n    /**\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.createActionStreams = function () {\n        var _this = this;\n        // Listens to all changes based on our instanceId\n        var /** @type {?} */ changes$ = share$1.call(this.createChangesObservable());\n        // Listen for the start action\n        var /** @type {?} */ start$ = filter$1.call(changes$, function (change) { return change.type === ExtensionActionTypes.START; });\n        // Listen for the stop action\n        var /** @type {?} */ stop$ = filter$1.call(changes$, function (change) { return change.type === ExtensionActionTypes.STOP; });\n        // Listen for lifted actions\n        var /** @type {?} */ liftedActions$ = applyOperators(changes$, [\n            [filter$1, function (change) { return change.type === ExtensionActionTypes.DISPATCH; }],\n            [map$1, function (change) { return _this.unwrapAction(change.payload); }],\n        ]);\n        // Listen for unlifted actions\n        var /** @type {?} */ actions$ = applyOperators(changes$, [\n            [filter$1, function (change) { return change.type === ExtensionActionTypes.ACTION; }],\n            [map$1, function (change) { return _this.unwrapAction(change.payload); }],\n        ]);\n        var /** @type {?} */ actionsUntilStop$ = takeUntil$1.call(actions$, stop$);\n        var /** @type {?} */ liftedUntilStop$ = takeUntil$1.call(liftedActions$, stop$);\n        // Only take the action sources between the start/stop events\n        this.actions$ = switchMap$1.call(start$, function () { return actionsUntilStop$; });\n        this.liftedActions$ = switchMap$1.call(start$, function () { return liftedUntilStop$; });\n    };\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    DevtoolsExtension.prototype.unwrapAction = function (action) {\n        return typeof action === 'string' ? eval(\"(\" + action + \")\") : action;\n    };\n    return DevtoolsExtension;\n}());\nvar INIT_ACTION = { type: INIT };\n/**\n * Computes the next entry in the log by applying an action.\n * @param {?} reducer\n * @param {?} action\n * @param {?} state\n * @param {?} error\n * @return {?}\n */\nfunction computeNextEntry(reducer, action, state, error) {\n    if (error) {\n        return {\n            state: state,\n            error: 'Interrupted by an error up the chain',\n        };\n    }\n    var /** @type {?} */ nextState = state;\n    var /** @type {?} */ nextError;\n    try {\n        nextState = reducer(state, action);\n    }\n    catch (err) {\n        nextError = err.toString();\n        console.error(err.stack || err);\n    }\n    return {\n        state: nextState,\n        error: nextError,\n    };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n * @param {?} computedStates\n * @param {?} minInvalidatedStateIndex\n * @param {?} reducer\n * @param {?} committedState\n * @param {?} actionsById\n * @param {?} stagedActionIds\n * @param {?} skippedActionIds\n * @return {?}\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds) {\n    // Optimization: exit early and return the same reference\n    // if we know nothing could have changed.\n    if (minInvalidatedStateIndex >= computedStates.length &&\n        computedStates.length === stagedActionIds.length) {\n        return computedStates;\n    }\n    var /** @type {?} */ nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n    for (var /** @type {?} */ i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n        var /** @type {?} */ actionId = stagedActionIds[i];\n        var /** @type {?} */ action = actionsById[actionId].action;\n        var /** @type {?} */ previousEntry = nextComputedStates[i - 1];\n        var /** @type {?} */ previousState = previousEntry ? previousEntry.state : committedState;\n        var /** @type {?} */ previousError = previousEntry ? previousEntry.error : undefined;\n        var /** @type {?} */ shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n        var /** @type {?} */ entry = shouldSkip\n            ? previousEntry\n            : computeNextEntry(reducer, action, previousState, previousError);\n        nextComputedStates.push(entry);\n    }\n    return nextComputedStates;\n}\n/**\n * @param {?=} initialCommittedState\n * @param {?=} monitorReducer\n * @return {?}\n */\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n    return {\n        monitorState: monitorReducer(undefined, {}),\n        nextActionId: 1,\n        actionsById: { 0: liftAction(INIT_ACTION) },\n        stagedActionIds: [0],\n        skippedActionIds: [],\n        committedState: initialCommittedState,\n        currentStateIndex: 0,\n        computedStates: [],\n    };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n * @param {?} initialCommittedState\n * @param {?} initialLiftedState\n * @param {?=} monitorReducer\n * @param {?=} options\n * @return {?}\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, monitorReducer, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    /**\n    * Manages how the history actions modify the history state.\n    */\n    return function (reducer) {\n        return function (liftedState, liftedAction) {\n            var _a = liftedState || initialLiftedState, monitorState = _a.monitorState, actionsById = _a.actionsById, nextActionId = _a.nextActionId, stagedActionIds = _a.stagedActionIds, skippedActionIds = _a.skippedActionIds, committedState = _a.committedState, currentStateIndex = _a.currentStateIndex, computedStates = _a.computedStates;\n            if (!liftedState) {\n                // Prevent mutating initialLiftedState\n                actionsById = Object.create(actionsById);\n            }\n            /**\n             * @param {?} n\n             * @return {?}\n             */\n            function commitExcessActions(n) {\n                // Auto-commits n-number of excess actions.\n                var /** @type {?} */ excess = n;\n                var /** @type {?} */ idsToDelete = stagedActionIds.slice(1, excess + 1);\n                for (var /** @type {?} */ i = 0; i < idsToDelete.length; i++) {\n                    if (computedStates[i + 1].error) {\n                        // Stop if error is found. Commit actions up to error.\n                        excess = i;\n                        idsToDelete = stagedActionIds.slice(1, excess + 1);\n                        break;\n                    }\n                    else {\n                        delete actionsById[idsToDelete[i]];\n                    }\n                }\n                skippedActionIds = skippedActionIds.filter(function (id) { return idsToDelete.indexOf(id) === -1; });\n                stagedActionIds = [0].concat(stagedActionIds.slice(excess + 1));\n                committedState = computedStates[excess].state;\n                computedStates = computedStates.slice(excess);\n                currentStateIndex =\n                    currentStateIndex > excess ? currentStateIndex - excess : 0;\n            }\n            // By default, agressively recompute every state whatever happens.\n            // This has O(n) performance, so we'll override this to a sensible\n            // value whenever we feel like we don't have to recompute the states.\n            var /** @type {?} */ minInvalidatedStateIndex = 0;\n            switch (liftedAction.type) {\n                case RESET: {\n                    // Get back to the state the store was created with.\n                    actionsById = { 0: liftAction(INIT_ACTION) };\n                    nextActionId = 1;\n                    stagedActionIds = [0];\n                    skippedActionIds = [];\n                    committedState = initialCommittedState;\n                    currentStateIndex = 0;\n                    computedStates = [];\n                    break;\n                }\n                case COMMIT: {\n                    // Consider the last committed state the new starting point.\n                    // Squash any staged actions into a single committed state.\n                    actionsById = { 0: liftAction(INIT_ACTION) };\n                    nextActionId = 1;\n                    stagedActionIds = [0];\n                    skippedActionIds = [];\n                    committedState = computedStates[currentStateIndex].state;\n                    currentStateIndex = 0;\n                    computedStates = [];\n                    break;\n                }\n                case ROLLBACK: {\n                    // Forget about any staged actions.\n                    // Start again from the last committed state.\n                    actionsById = { 0: liftAction(INIT_ACTION) };\n                    nextActionId = 1;\n                    stagedActionIds = [0];\n                    skippedActionIds = [];\n                    currentStateIndex = 0;\n                    computedStates = [];\n                    break;\n                }\n                case TOGGLE_ACTION: {\n                    // Toggle whether an action with given ID is skipped.\n                    // Being skipped means it is a no-op during the computation.\n                    var actionId_1 = liftedAction.id;\n                    var /** @type {?} */ index = skippedActionIds.indexOf(actionId_1);\n                    if (index === -1) {\n                        skippedActionIds = [actionId_1].concat(skippedActionIds);\n                    }\n                    else {\n                        skippedActionIds = skippedActionIds.filter(function (id) { return id !== actionId_1; });\n                    }\n                    // Optimization: we know history before this action hasn't changed\n                    minInvalidatedStateIndex = stagedActionIds.indexOf(actionId_1);\n                    break;\n                }\n                case SET_ACTIONS_ACTIVE: {\n                    // Toggle whether an action with given ID is skipped.\n                    // Being skipped means it is a no-op during the computation.\n                    var start = liftedAction.start, end = liftedAction.end, active = liftedAction.active;\n                    var /** @type {?} */ actionIds = [];\n                    for (var /** @type {?} */ i = start; i < end; i++)\n                        actionIds.push(i);\n                    if (active) {\n                        skippedActionIds = difference(skippedActionIds, actionIds);\n                    }\n                    else {\n                        skippedActionIds = skippedActionIds.concat(actionIds);\n                    }\n                    // Optimization: we know history before this action hasn't changed\n                    minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                    break;\n                }\n                case JUMP_TO_STATE: {\n                    // Without recomputing anything, move the pointer that tell us\n                    // which state is considered the current one. Useful for sliders.\n                    currentStateIndex = liftedAction.index;\n                    // Optimization: we know the history has not changed.\n                    minInvalidatedStateIndex = Infinity;\n                    break;\n                }\n                case SWEEP: {\n                    // Forget any actions that are currently being skipped.\n                    stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                    skippedActionIds = [];\n                    currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                    break;\n                }\n                case PERFORM_ACTION: {\n                    // Auto-commit as new actions come in.\n                    if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                        commitExcessActions(1);\n                    }\n                    if (currentStateIndex === stagedActionIds.length - 1) {\n                        currentStateIndex++;\n                    }\n                    var /** @type {?} */ actionId = nextActionId++;\n                    // Mutation! This is the hottest path, and we optimize on purpose.\n                    // It is safe because we set a new key in a cache dictionary.\n                    actionsById[actionId] = liftedAction;\n                    stagedActionIds = stagedActionIds.concat([actionId]);\n                    // Optimization: we know that only the new action needs computing.\n                    minInvalidatedStateIndex = stagedActionIds.length - 1;\n                    break;\n                }\n                case IMPORT_STATE: {\n                    // Completely replace everything.\n                    (_b = liftedAction.nextLiftedState, monitorState = _b.monitorState, actionsById = _b.actionsById, nextActionId = _b.nextActionId, stagedActionIds = _b.stagedActionIds, skippedActionIds = _b.skippedActionIds, committedState = _b.committedState, currentStateIndex = _b.currentStateIndex, computedStates = _b.computedStates);\n                    break;\n                }\n                case UPDATE:\n                case INIT: {\n                    // Always recompute states on hot reload and init.\n                    minInvalidatedStateIndex = 0;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        // States must be recomputed before committing excess.\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds);\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                        // Avoid double computation.\n                        minInvalidatedStateIndex = Infinity;\n                    }\n                    break;\n                }\n                default: {\n                    // If the action is not recognized, it's a monitor action.\n                    // Optimization: a monitor action can't change history.\n                    minInvalidatedStateIndex = Infinity;\n                    break;\n                }\n            }\n            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds);\n            monitorState = monitorReducer(monitorState, liftedAction);\n            return {\n                monitorState: monitorState,\n                actionsById: actionsById,\n                nextActionId: nextActionId,\n                stagedActionIds: stagedActionIds,\n                skippedActionIds: skippedActionIds,\n                committedState: committedState,\n                currentStateIndex: currentStateIndex,\n                computedStates: computedStates,\n            };\n            var _b;\n        };\n    };\n}\nvar StoreDevtoolsConfig = /*@__PURE__*/ (function () {\n    function StoreDevtoolsConfig() {\n    }\n    return StoreDevtoolsConfig;\n}());\nvar STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/devtools Options');\nvar INITIAL_OPTIONS = new InjectionToken('@ngrx/devtools Initial Config');\nvar DevtoolsDispatcher = /*@__PURE__*/ (function (_super) {\n    __extends(DevtoolsDispatcher, _super);\n    function DevtoolsDispatcher() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return DevtoolsDispatcher;\n}(ActionsSubject));\nvar StoreDevtools = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} dispatcher\n     * @param {?} actions$\n     * @param {?} reducers$\n     * @param {?} extension\n     * @param {?} scannedActions\n     * @param {?} initialState\n     * @param {?} config\n     */\n    function StoreDevtools(dispatcher, actions$, reducers$, extension, scannedActions, initialState, config) {\n        var liftedInitialState = liftInitialState(initialState, config.monitor);\n        var liftReducer = liftReducerWith(initialState, liftedInitialState, config.monitor, config.maxAge ? { maxAge: config.maxAge } : {});\n        var liftedAction$ = applyOperators(actions$.asObservable(), [\n            [skip$1, 1],\n            [merge$1, extension.actions$],\n            [map$1, liftAction],\n            [merge$1, dispatcher, extension.liftedActions$],\n            [observeOn$1, queue$1],\n        ]);\n        var liftedReducer$ = map$1.call(reducers$, liftReducer);\n        var liftedStateSubject = new ReplaySubject$1(1);\n        var liftedStateSubscription = applyOperators(liftedAction$, [\n            [withLatestFrom$1, liftedReducer$],\n            [\n                scan$1,\n                function (_a, _b) {\n                    var liftedState = _a.state;\n                    var action = _b[0], reducer = _b[1];\n                    var state = reducer(liftedState, action);\n                    extension.notify(action, state);\n                    return { state: state, action: action };\n                },\n                { state: liftedInitialState, action: null },\n            ],\n        ]).subscribe(function (_a) {\n            var state = _a.state, action = _a.action;\n            liftedStateSubject.next(state);\n            if (action.type === PERFORM_ACTION) {\n                var unlifedAction = action.action;\n                scannedActions.next(unlifedAction);\n            }\n        });\n        var liftedState$ = liftedStateSubject.asObservable();\n        var state$ = map$1.call(liftedState$, unliftState);\n        this.stateSubscription = liftedStateSubscription;\n        this.dispatcher = dispatcher;\n        this.liftedState = liftedState$;\n        this.state = state$;\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    StoreDevtools.prototype.dispatch = function (action) {\n        this.dispatcher.next(action);\n    };\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    StoreDevtools.prototype.next = function (action) {\n        this.dispatcher.next(action);\n    };\n    /**\n     * @param {?} error\n     * @return {?}\n     */\n    StoreDevtools.prototype.error = function (error) { };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.complete = function () { };\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    StoreDevtools.prototype.performAction = function (action) {\n        this.dispatch(new PerformAction(action));\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.reset = function () {\n        this.dispatch(new Reset());\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.rollback = function () {\n        this.dispatch(new Rollback());\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.commit = function () {\n        this.dispatch(new Commit());\n    };\n    /**\n     * @return {?}\n     */\n    StoreDevtools.prototype.sweep = function () {\n        this.dispatch(new Sweep());\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    StoreDevtools.prototype.toggleAction = function (id) {\n        this.dispatch(new ToggleAction(id));\n    };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    StoreDevtools.prototype.jumpToState = function (index) {\n        this.dispatch(new JumpToState(index));\n    };\n    /**\n     * @param {?} nextLiftedState\n     * @return {?}\n     */\n    StoreDevtools.prototype.importState = function (nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n    };\n    return StoreDevtools;\n}());\nvar IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('Is Devtools Extension or Monitor Present');\n/**\n * @param {?} extension\n * @param {?} config\n * @return {?}\n */\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n    return Boolean(extension) || config.monitor !== noMonitor;\n}\n/**\n * @return {?}\n */\nfunction createReduxDevtoolsExtension() {\n    var /** @type {?} */ extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n    if (typeof window === 'object' &&\n        typeof ((window))[extensionKey] !== 'undefined') {\n        return ((window))[extensionKey];\n    }\n    else {\n        return null;\n    }\n}\n/**\n * @param {?} devtools\n * @return {?}\n */\nfunction createStateObservable(devtools) {\n    return devtools.state;\n}\n/**\n * @return {?}\n */\nfunction noMonitor() {\n    return null;\n}\n/**\n * @param {?} _options\n * @return {?}\n */\nfunction createConfig(_options) {\n    var /** @type {?} */ DEFAULT_OPTIONS = {\n        maxAge: false,\n        monitor: noMonitor,\n    };\n    var /** @type {?} */ options = typeof _options === 'function' ? _options() : _options;\n    var /** @type {?} */ config = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (config.maxAge && config.maxAge < 2) {\n        throw new Error(\"Devtools 'maxAge' cannot be less than 2, got \" + config.maxAge);\n    }\n    return config;\n}\nvar StoreDevtoolsModule = /*@__PURE__*/ (function () {\n    function StoreDevtoolsModule() {\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    StoreDevtoolsModule.instrument = function (options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return {\n            ngModule: StoreDevtoolsModule,\n            providers: [\n                DevtoolsExtension,\n                DevtoolsDispatcher,\n                StoreDevtools,\n                {\n                    provide: INITIAL_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n                    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n                    useFactory: createIsExtensionOrMonitorPresent,\n                },\n                {\n                    provide: REDUX_DEVTOOLS_EXTENSION,\n                    useFactory: createReduxDevtoolsExtension,\n                },\n                {\n                    provide: STORE_DEVTOOLS_CONFIG,\n                    deps: [INITIAL_OPTIONS],\n                    useFactory: createConfig,\n                },\n                {\n                    provide: StateObservable,\n                    deps: [StoreDevtools],\n                    useFactory: createStateObservable,\n                },\n                {\n                    provide: ReducerManagerDispatcher,\n                    useExisting: DevtoolsDispatcher,\n                },\n            ],\n        };\n    };\n    return StoreDevtoolsModule;\n}());\n/**\n * Generated bundle index. Do not edit.\n */\nexport { StoreDevtoolsModule, StoreDevtools, StoreDevtoolsConfig, INITIAL_OPTIONS as ɵi, STORE_DEVTOOLS_CONFIG as ɵh, DevtoolsDispatcher as ɵg, DevtoolsExtension as ɵk, REDUX_DEVTOOLS_EXTENSION as ɵj, IS_EXTENSION_OR_MONITOR_PRESENT as ɵa, createConfig as ɵf, createIsExtensionOrMonitorPresent as ɵb, createReduxDevtoolsExtension as ɵc, createStateObservable as ɵd, noMonitor as ɵe };\n//# sourceMappingURL=store-devtools.es5.js.map\n",null]}